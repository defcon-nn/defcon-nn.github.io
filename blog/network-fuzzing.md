# Цикл статей "Фаззинг сетевых компонент"

## Введение в теорию фаззинга

В рамках цикла мы разберем методы фаззинг-тестирования различных программ, так или иначе работающих с сетью.
Знакомство с техникой фаззинга не требуется -- вся необходимая информация будет даваться по ходу дела.

Фаззинг-тестирование -- это тестирование программы с автоматизированным созданием тестов (входных данных). Как правило используется большое количество входных данных.

Выделяют следующие виды фаззинга:
- Черный ящик
- Серый ящик

В случае черного ящика фаззер не имеет никакого понятия и обратной связи с тестируемым приложением. Самый простой пример фаззинга в режиме черного ящика -- чтение из `/dev/urandom` и подача этих случайных данных на вход тестируемой программы:
```
$ cat /dev/urandom | program
```

Здесь в качестве фаззера используется генератор псевдослучайных чисел `/dev/urandom`. На практике эффективность использования (псевдо)случайных входных данных в большинстве случаев низкая -- слишком медленно получаются такие наборы, которые приводят к новым веткам дерева исполнения программы: обычно они все отсекаются на самых ранних проверках. Для решения этой проблемы были придуманы **мутирующие** фаззеры: для своей работы они требуют некоторый набор валидных входных данных, называемый __корпусом__. Эти данные используются при создании тестовых входных данных путём так называемых мутаций -- например, смены значения одного бита (bit flip), байта (byte flip), какой-нибудь арифметической операции и т.д.

Примером такого фаззера служит [radamsa](https://gitlab.com/akihe/radamsa). В её арсенале большое количество продвинутых мутаторов и генераторов. При этом в принципе не обязательно предоставлять ей начальный корпус, но без него эффективность тестирования, очевидно, будет значительно хуже. Заметим, что несмотря на использование исходного корпуса, такие фаззеры по-прежнему считаются фаззерами черного ящика, потому что просто "выплёвывают" некоторые данные на вход программе, ничего больше не анализируя. В некоторых случаях только такой подход и возможен -- например, когда доступ к исполняемым файлам и процессам невозможен. Полезной функцией Радамсы является возможность отправлять данные в TCP-сокет, или же играть роль сервера (для тестирования клиентов).

... [TODO] ...

## Фаззинг структурированного полубинарного сетевого протокола

### Подготовка окружения

Для работы потребуется компьютер или виртуальна машина с установленным дистрибутивом Linux. В нем нужно установить следующий софт:
- gdb, gcc, clang + llvm (нам понадобится asan), python3, wireshark, git, radare2
- radamsa (https://gitlab.com/akihe/radamsa)
- afl (http://lcamtuf.coredump.cx/afl/)
- afl-utils (https://gitlab.com/rc0r/afl-utils/blob/master/docs/INSTALL.md)

Вариант установки afl-utils с использованием python3's virtualenv в директорию $HOME/lib:

```
$ mkdir ~/lib
$ cd ~/lib
$ git clone https://gitlab.com/rc0r/afl-utils
$ virtualenv -p python3 venv
$ source venv/bin/activate
$ cd afl-utils
$ python setup.py install
```

Чтобы плагин exploitable для gdb заработал, выполните, подставив свой путь до exploitable.py:
```
$ echo "source /home/user/lib/venv/lib/python3.7/site-packages/exploitable-1.32_rcor-py3.7.egg/exploitable/exploitable.py" >> ~/.gdbinit
```

Склонировать репозиторий с демо-приложением:

```
git clone https://gitlab.com/DC_ZN/chatserv
git submodule init
git submodule update
```

**Замечание.** Это приложение было вдохновлено приложением SuperFunkyChat из книги [James Forshaw. Attacking Network Protocols, 2017](http://libgen.io/search.php?req=Attacking+Network+Protocols&lg_topic=libgen&open=0&view=simple&res=25&phrase=1&column=def).

### Знакомство с модельным приложением chatserv

Начнём изучение модельного приложения chatserv. По его `Makefile` можно понять, что в репозитории находятся такие программы:
```
all: chatd chat-cli exploit chat-fuzz chatd-stdin
```

- chatd: чат-сервер, который мы будем фаззить
- chat-cli: консольный клиент для этого чат-сервера (Замечание: в репозитории https://gitlab.com/DC_ZN/tel-yo-gram лежит клиент под Андроид)
- chatd-stdin: модифицированный сервер, работающий со стандартным вводом вместо tcp-сокета (разбирается далее)

Остальные нас интересовать не будут, но чтобы не возникало вопросов, опишем и их:
- chat-fuzz: неоконченная попытка сделать перенаправление stdin в tcp-сокет; такой подход не имеет смысла для afl, но может быть полезен для radamsa, если добавить пост-процессирование (см. далее).
- exploit: прототип эксплойта для уязвимости в chatd - одно из заданий квеста DefHack. Уязвимость path traversal, найти её фаззингом будет достаточно сложно (можно попробовать в качестве домашнего задания).

Давайте скомпилируем и запустим сервер и клиентов, чтобы посмотреть, как они работают:

```
[user@defcon chatserv]$ make
<...>
[user@defcon chatserv]$ ./chatd
waiting for connections at 0.0.0.0:4000...
server.c:431:main(): Starting epoll_wait, timeout=-1
```
Видим, что сервер запускается на публичном интерфейсе `0.0.0.0`, на порту `4000`. 

**Замечание 1.** Для простоты реализации модельного сервера в нем не сделан модуль конфигурации, значения по умолчанию удобны для размещения сервера в докер-контейнере. Адрес и порт можно поменять, только отредактировав исходный код chatd (файл `server.c`).

 **Замечание 2.** Очевидно, если вы запускаете chatd на интерфейсе `0.0.0.0` в какой-то недоверенной сети (например, публичный Wifi) без использования механизма изоляции (виртуальная машина, контейнер), это открывает вас к угрозам безопасности. Менее очевидно, что даже если заменить публичный интерфейс (адрес 0.0.0.0) на локальный (адрес 127.0.0.1, localhost), то недоверенные скрипты, исполняющиеся в вашем браузере, могут обратиться к этому сервису (см. например [вопрос на stackoverflow][1], [эксплуатируемый баг в Transmission][2], [статью про атаки на локальные инстансы Redis, Memcached, Elasticsearch][3], [сканер портов локальной сети из браузера][4]). Способы защиты:
- Использовать виртуальную машину для запуска сервисов; не открывать недоверенные сайты из браузера в этой машине
- Использовать Firefox с NoScript
- Запускать сервисы с минимальными привилегиями, в "песочнице"

[1]: https://security.stackexchange.com/questions/177486/can-websites-access-computers-in-lan-localhost-through-browser-how-to-block-th
[2]: https://github.com/transmission/transmission/pull/468
[3]: https://web.archive.org/web/20181130174629/https://bouk.co/blog/hacking-developers/
[4]: https://defuse.ca/in-browser-port-scanning.htm

**Замечание 3.** Мы планируем проводить фаззинг-тестирование, в результате которого может произойти выполнение неожиданного кода ("произвольного", хотя и не намеренно вредоносного) с правами текущего пользователя. Для защиты от повреждения окружения этого пользователя необходимо использовать какую-то систему изоляции. Простой и достаточный для защиты от ошибок во время фаззинга вариант -- создать отдельного ограниченного пользователя, не имеющего доступ на запись за исключением явных разрешений. На Debian-подобных дистрибутивах для этого используется команда `adduser`:
```
$ sudo adduser -s fuzzuser
```
Во всех остальных используется команда `useradd`:
```
$ sudo useradd --no-create-home fuzzuser
```

После этого запускаем сервер снова, уже из-под ограниченного пользователя:
```
[user@defcon chatserv]$ su fuzzuser
[fuzzuser@defcon chatserv]$ ./chatd
waiting for connections at 0.0.0.0:4000...
server.c:431:main(): Starting epoll_wait, timeout=-1
```

Запустим клиент (можно из-под обычного пользователя -- некритично):
```
[user@defcon chatserv]$ ./chat-cli
Usage: ./chat-cli host port
```
Как видим, надо указать хост и порт, в нашем случае `localhost 4000` (хотя можете попробовать запускать клиенты и на других хостах -- всё будет работать по сети).

Запускаем несколько тестовых клиентов (для этого удобно использовать терминал с поддержкой разделения на несколько в одном окне - например, `terminator`, или `tmux`):
![]() // картинка с 4мя терминалами

Как видим, чат более-менее работает. Заметны баги с отправкой и доставкой сообщений -- иногда доставляются только вместе со следующим или при отправке ответа; скорее всего баг в клиенте, он вообще был написан за пару часов -- насколько помню, в джавовом клиенте под Андроид, tel-yo-gram, этот баг не проявляется.

### Анализ чат-протокола

Следующим шагом в нашей работе является анализ протокола взаимодействия чат-клиента и сервера. Для этого мы используем wireshark. Прежде чем запускать его, подготовим окружение - закроем все клиенты (по Ctrl+C), перезапустим сервер (он не является stateless, т.к. хранит историю сообщений и отдает её новым клиентам при подключении). Теперь запускаем wireshark, выбираем захват трафика на локальной петле `lo`:
![]() // картинка с wireshark lo
Запускаем клиент:
```
[user@defcon chatserv]$ ./chat-cli localhost 4000
Connecting to chat server...success.
Enter your nick:
```
В это время в wireshark видим такую картину:
![]() // картинка wireshark первые 5 пакетов

Можно видеть, что первые два пакета имеют Source и Destination IPv6-адрес ::1. Сервер слушает на IPv4-адресе, поэтому операционная система отсылает RST-пакет на SYN-пакет от клиента. Следующие три пакета - установка TCP-соединения, классическое трехстороннее рукопожатие SYN-SYN,ACK-ACK. Никаких пользовательских данных в этот момент ещё не передается.

Вводим ник, нажимаем Enter:
```
[user@defcon chatserv]$ ./chat-cli localhost 4000
Connecting to chat server...success.
Enter your nick: wsnark
Logging in...success. Say hello to the chat!
> 
```
и в wireshark видим:
![]() // картинка wireshark первые данные (два PSH,ACK)

Данные от клиента передаются на сервер в первом сообщении PSH,ACK; ответ сервера - во втором. Наконец, вводим сообщение:
```
[user@defcon chatserv]$ ./chat-cli localhost 4000
Connecting to chat server...success.
Enter your nick: wsnark
Logging in...success. Say hello to the chat!
> Hello, world!
> 
```
Наблюдаем в wireshark ещё одну пару PSH,ACK'ов.
![]() // картинка wireshark все данные

Для начала достаточно, останавливаем захват. Теперь давайте посмотрим, что за данные мы захватили. Почти во всех сообщениях PSH,ACK есть текстовые данные - это ник и текст сообщения. Но всё остальное выглядит в ASCII-превью как набор "...", соответствующих неотображаемым как символы значениям. Ясно, что мы имеем дело с полубинарным протоколом.

После просмотра отдельных сообщений PSH,ACK, давайте посмотрим на TCP-поток целиком. Для этого выбираем одно из сообщений, кликаем по нему правой кнопкой и выбираем "Follow -> TCP Stream":
![]() // картинка wireshark - выбор Follow -> TCP Stream.
Открывается отдельное окно:
![]() // картинка wireshark - follow tcp stream

Здесь мы можем удобно наблюдать за сообщениями, которыми обменялись стороны, причем в том порядке, в каком это происходило. Красные символы соответствуют сообщениям от клиента, синие - от сервера.

Первое сообщение от клиента начинается с набора символов "INHAT". Это так называемое "магический символ" протокола (protocol magic), который позволяет серверу при подключении новых клиентов отличать понимающих этот протокол от всех остальных.

Метод пристального вглядывания не очень эффективен при анализе полубинарного протокола, по-крайней мере если вы не обладаете навыками опытного реверсера, свободно читающего и интерпретирующего шестнадцатиричные числа, записанные в сетевом порядке байт (network byte order = big endian byte order - порядок байт, обычно применяемый при передаче данных по сети; в отличие от little endian, применяемого в при работе с памятью в архитектуре x86 и в большинстве случаев на arm).

Давайте экспортируем все переданные полезные данные в файл в сыром (raw) виде, причем отдельно данные от клиента и от сервера. Для этого выбираем режим Raw:
![]() // картинка wireshark - raw
в комбо-боксе "Entire conversation (92 bytes)" xxxx->4000 (клиентские данные), затем нажимаем Save as... и сохраняем. Затем то же самое повторяем для серверного ответа (4000->xxxx).

Также стоит сохранить все полученные пакеты в формате pcapng (File -> Save).

Стоит проверить raw-файлы на валидность, заодно освоив удобный метод их просмотра в терминале с помощью команды hexdump:

```
[user@defcon capture-for-blog]$ hexdump -C helloworld-client.raw 
00000000  49 4e 48 41 54 01 00 00  00 00 0c 00 00 02 96 00  |INHAT...........|
00000010  00 77 73 6e 61 72 6b 00  00 00 14 00 00 04 96 00  |.wsnark.........|
00000020  03 48 65 6c 6c 6f 2c 20  77 6f 72 6c 64 21 0a     |.Hello, world!.|
0000002f
```
опция -C включает "каноничный" режим hex+ASCII (его же можно наблюдать в окне Follow Stream в режиме Hex Dump).

## Фаззинг cgi-скрипта CGit




